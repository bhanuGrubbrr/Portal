/* eslint-disable */
// @generated by protobuf-ts 2.9.0 with parameter ts_nocheck,eslint_disable,add_pb_suffix,long_type_string,generate_dependencies
// @generated from protobuf file "kioskConfigService.proto" (package "Mgmt", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ConceptsResponse } from "./kioskConfig_pb";
import { EmptyResponse } from "./common_pb";
import { GratuityTendersVM } from "./kioskConfig_pb";
import { KioskConfigVM } from "./kioskConfig_pb";
import { LocationRequest } from "./common_pb";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TipSettingsVM } from "./kioskConfig_pb";
import { BusinessHoursConfigurationVM } from "./kioskConfig_pb";
import { TimeoutSettingsVM } from "./kioskConfig_pb";
import { AgeVerificationSettingsVM } from "./kioskConfig_pb";
import { OrderTokenSettingsVM } from "./kioskConfig_pb";
import { PosOrderTypeVM } from "./kioskConfig_pb";
import { OrderTypeOptionVM } from "./kioskConfig_pb";
import { LocalizationVM } from "./kioskConfig_pb";
import { ConceptVM } from "./kioskConfig_pb";
/**
 * @generated from protobuf message Mgmt.FeatureFlagRequest
 */
export interface FeatureFlagRequest {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: bool isEnabled = 2;
     */
    isEnabled: boolean;
}
/**
 * @generated from protobuf message Mgmt.ConceptFeatureFlagRequest
 */
export interface ConceptFeatureFlagRequest {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: bool isEnabled = 2;
     */
    isEnabled: boolean;
}
/**
 * @generated from protobuf message Mgmt.RemoveConceptRequest
 */
export interface RemoveConceptRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string locationId = 2;
     */
    locationId: string;
}
/**
 * @generated from protobuf message Mgmt.ReorderConceptsRequest
 */
export interface ReorderConceptsRequest {
    /**
     * @generated from protobuf field: repeated string ordered_ids = 1;
     */
    orderedIds: string[];
    /**
     * @generated from protobuf field: string locationId = 2;
     */
    locationId: string;
}
/**
 * @generated from protobuf message Mgmt.ConceptRequest
 */
export interface ConceptRequest {
    /**
     * @generated from protobuf field: Mgmt.ConceptVM concept = 1;
     */
    concept?: ConceptVM;
    /**
     * @generated from protobuf field: string locationId = 2;
     */
    locationId: string;
}
/**
 * @generated from protobuf message Mgmt.LocalizationRequest
 */
export interface LocalizationRequest {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: Mgmt.LocalizationVM localization = 2;
     */
    localization?: LocalizationVM;
}
/**
 * @generated from protobuf message Mgmt.OrderTypesResponse
 */
export interface OrderTypesResponse {
    /**
     * @generated from protobuf field: repeated Mgmt.OrderTypeOptionVM options = 1;
     */
    options: OrderTypeOptionVM[];
    /**
     * @generated from protobuf field: repeated Mgmt.PosOrderTypeVM posOrderTypes = 2;
     */
    posOrderTypes: PosOrderTypeVM[];
}
/**
 * @generated from protobuf message Mgmt.UpsertOrderTypesRequest
 */
export interface UpsertOrderTypesRequest {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: repeated Mgmt.OrderTypeOptionVM orderTypeOptions = 2;
     */
    orderTypeOptions: OrderTypeOptionVM[];
}
/**
 * @generated from protobuf message Mgmt.UpsertOrderTokenRequest
 */
export interface UpsertOrderTokenRequest {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: Mgmt.OrderTokenSettingsVM tokenSettings = 2;
     */
    tokenSettings?: OrderTokenSettingsVM;
}
/**
 * @generated from protobuf message Mgmt.AgeVerificationSettingsRequest
 */
export interface AgeVerificationSettingsRequest {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: Mgmt.AgeVerificationSettingsVM settings = 2;
     */
    settings?: AgeVerificationSettingsVM;
}
/**
 * @generated from protobuf message Mgmt.TimeoutSettingsRequest
 */
export interface TimeoutSettingsRequest {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: Mgmt.TimeoutSettingsVM settings = 2;
     */
    settings?: TimeoutSettingsVM;
}
/**
 * @generated from protobuf message Mgmt.BusinessHoursRequest
 */
export interface BusinessHoursRequest {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: Mgmt.BusinessHoursConfigurationVM configuration = 2;
     */
    configuration?: BusinessHoursConfigurationVM;
}
/**
 * @generated from protobuf message Mgmt.TipSettingsRequest
 */
export interface TipSettingsRequest {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: Mgmt.TipSettingsVM settings = 2;
     */
    settings?: TipSettingsVM;
}
// @generated message type with reflection information, may provide speed optimized methods
class FeatureFlagRequest$Type extends MessageType<FeatureFlagRequest> {
    constructor() {
        super("Mgmt.FeatureFlagRequest", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "isEnabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FeatureFlagRequest>): FeatureFlagRequest {
        const message = { locationId: "", isEnabled: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeatureFlagRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeatureFlagRequest): FeatureFlagRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* bool isEnabled */ 2:
                    message.isEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeatureFlagRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* bool isEnabled = 2; */
        if (message.isEnabled !== false)
            writer.tag(2, WireType.Varint).bool(message.isEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.FeatureFlagRequest
 */
export const FeatureFlagRequest = new FeatureFlagRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConceptFeatureFlagRequest$Type extends MessageType<ConceptFeatureFlagRequest> {
    constructor() {
        super("Mgmt.ConceptFeatureFlagRequest", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "isEnabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ConceptFeatureFlagRequest>): ConceptFeatureFlagRequest {
        const message = { locationId: "", isEnabled: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConceptFeatureFlagRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConceptFeatureFlagRequest): ConceptFeatureFlagRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* bool isEnabled */ 2:
                    message.isEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConceptFeatureFlagRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* bool isEnabled = 2; */
        if (message.isEnabled !== false)
            writer.tag(2, WireType.Varint).bool(message.isEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.ConceptFeatureFlagRequest
 */
export const ConceptFeatureFlagRequest = new ConceptFeatureFlagRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveConceptRequest$Type extends MessageType<RemoveConceptRequest> {
    constructor() {
        super("Mgmt.RemoveConceptRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveConceptRequest>): RemoveConceptRequest {
        const message = { id: "", locationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RemoveConceptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveConceptRequest): RemoveConceptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string locationId */ 2:
                    message.locationId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveConceptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string locationId = 2; */
        if (message.locationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.locationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.RemoveConceptRequest
 */
export const RemoveConceptRequest = new RemoveConceptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReorderConceptsRequest$Type extends MessageType<ReorderConceptsRequest> {
    constructor() {
        super("Mgmt.ReorderConceptsRequest", [
            { no: 1, name: "ordered_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReorderConceptsRequest>): ReorderConceptsRequest {
        const message = { orderedIds: [], locationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReorderConceptsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReorderConceptsRequest): ReorderConceptsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string ordered_ids */ 1:
                    message.orderedIds.push(reader.string());
                    break;
                case /* string locationId */ 2:
                    message.locationId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReorderConceptsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string ordered_ids = 1; */
        for (let i = 0; i < message.orderedIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.orderedIds[i]);
        /* string locationId = 2; */
        if (message.locationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.locationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.ReorderConceptsRequest
 */
export const ReorderConceptsRequest = new ReorderConceptsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConceptRequest$Type extends MessageType<ConceptRequest> {
    constructor() {
        super("Mgmt.ConceptRequest", [
            { no: 1, name: "concept", kind: "message", T: () => ConceptVM },
            { no: 2, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConceptRequest>): ConceptRequest {
        const message = { locationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConceptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConceptRequest): ConceptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Mgmt.ConceptVM concept */ 1:
                    message.concept = ConceptVM.internalBinaryRead(reader, reader.uint32(), options, message.concept);
                    break;
                case /* string locationId */ 2:
                    message.locationId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConceptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Mgmt.ConceptVM concept = 1; */
        if (message.concept)
            ConceptVM.internalBinaryWrite(message.concept, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string locationId = 2; */
        if (message.locationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.locationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.ConceptRequest
 */
export const ConceptRequest = new ConceptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalizationRequest$Type extends MessageType<LocalizationRequest> {
    constructor() {
        super("Mgmt.LocalizationRequest", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "localization", kind: "message", T: () => LocalizationVM }
        ]);
    }
    create(value?: PartialMessage<LocalizationRequest>): LocalizationRequest {
        const message = { locationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LocalizationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalizationRequest): LocalizationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* Mgmt.LocalizationVM localization */ 2:
                    message.localization = LocalizationVM.internalBinaryRead(reader, reader.uint32(), options, message.localization);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalizationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* Mgmt.LocalizationVM localization = 2; */
        if (message.localization)
            LocalizationVM.internalBinaryWrite(message.localization, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.LocalizationRequest
 */
export const LocalizationRequest = new LocalizationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderTypesResponse$Type extends MessageType<OrderTypesResponse> {
    constructor() {
        super("Mgmt.OrderTypesResponse", [
            { no: 1, name: "options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OrderTypeOptionVM },
            { no: 2, name: "posOrderTypes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PosOrderTypeVM }
        ]);
    }
    create(value?: PartialMessage<OrderTypesResponse>): OrderTypesResponse {
        const message = { options: [], posOrderTypes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderTypesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderTypesResponse): OrderTypesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Mgmt.OrderTypeOptionVM options */ 1:
                    message.options.push(OrderTypeOptionVM.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Mgmt.PosOrderTypeVM posOrderTypes */ 2:
                    message.posOrderTypes.push(PosOrderTypeVM.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderTypesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Mgmt.OrderTypeOptionVM options = 1; */
        for (let i = 0; i < message.options.length; i++)
            OrderTypeOptionVM.internalBinaryWrite(message.options[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated Mgmt.PosOrderTypeVM posOrderTypes = 2; */
        for (let i = 0; i < message.posOrderTypes.length; i++)
            PosOrderTypeVM.internalBinaryWrite(message.posOrderTypes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.OrderTypesResponse
 */
export const OrderTypesResponse = new OrderTypesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertOrderTypesRequest$Type extends MessageType<UpsertOrderTypesRequest> {
    constructor() {
        super("Mgmt.UpsertOrderTypesRequest", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orderTypeOptions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OrderTypeOptionVM }
        ]);
    }
    create(value?: PartialMessage<UpsertOrderTypesRequest>): UpsertOrderTypesRequest {
        const message = { locationId: "", orderTypeOptions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpsertOrderTypesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertOrderTypesRequest): UpsertOrderTypesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* repeated Mgmt.OrderTypeOptionVM orderTypeOptions */ 2:
                    message.orderTypeOptions.push(OrderTypeOptionVM.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertOrderTypesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* repeated Mgmt.OrderTypeOptionVM orderTypeOptions = 2; */
        for (let i = 0; i < message.orderTypeOptions.length; i++)
            OrderTypeOptionVM.internalBinaryWrite(message.orderTypeOptions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.UpsertOrderTypesRequest
 */
export const UpsertOrderTypesRequest = new UpsertOrderTypesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertOrderTokenRequest$Type extends MessageType<UpsertOrderTokenRequest> {
    constructor() {
        super("Mgmt.UpsertOrderTokenRequest", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tokenSettings", kind: "message", T: () => OrderTokenSettingsVM }
        ]);
    }
    create(value?: PartialMessage<UpsertOrderTokenRequest>): UpsertOrderTokenRequest {
        const message = { locationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpsertOrderTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertOrderTokenRequest): UpsertOrderTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* Mgmt.OrderTokenSettingsVM tokenSettings */ 2:
                    message.tokenSettings = OrderTokenSettingsVM.internalBinaryRead(reader, reader.uint32(), options, message.tokenSettings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertOrderTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* Mgmt.OrderTokenSettingsVM tokenSettings = 2; */
        if (message.tokenSettings)
            OrderTokenSettingsVM.internalBinaryWrite(message.tokenSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.UpsertOrderTokenRequest
 */
export const UpsertOrderTokenRequest = new UpsertOrderTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgeVerificationSettingsRequest$Type extends MessageType<AgeVerificationSettingsRequest> {
    constructor() {
        super("Mgmt.AgeVerificationSettingsRequest", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "settings", kind: "message", T: () => AgeVerificationSettingsVM }
        ]);
    }
    create(value?: PartialMessage<AgeVerificationSettingsRequest>): AgeVerificationSettingsRequest {
        const message = { locationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AgeVerificationSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgeVerificationSettingsRequest): AgeVerificationSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* Mgmt.AgeVerificationSettingsVM settings */ 2:
                    message.settings = AgeVerificationSettingsVM.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgeVerificationSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* Mgmt.AgeVerificationSettingsVM settings = 2; */
        if (message.settings)
            AgeVerificationSettingsVM.internalBinaryWrite(message.settings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.AgeVerificationSettingsRequest
 */
export const AgeVerificationSettingsRequest = new AgeVerificationSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeoutSettingsRequest$Type extends MessageType<TimeoutSettingsRequest> {
    constructor() {
        super("Mgmt.TimeoutSettingsRequest", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "settings", kind: "message", T: () => TimeoutSettingsVM }
        ]);
    }
    create(value?: PartialMessage<TimeoutSettingsRequest>): TimeoutSettingsRequest {
        const message = { locationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TimeoutSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeoutSettingsRequest): TimeoutSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* Mgmt.TimeoutSettingsVM settings */ 2:
                    message.settings = TimeoutSettingsVM.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeoutSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* Mgmt.TimeoutSettingsVM settings = 2; */
        if (message.settings)
            TimeoutSettingsVM.internalBinaryWrite(message.settings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.TimeoutSettingsRequest
 */
export const TimeoutSettingsRequest = new TimeoutSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BusinessHoursRequest$Type extends MessageType<BusinessHoursRequest> {
    constructor() {
        super("Mgmt.BusinessHoursRequest", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "configuration", kind: "message", T: () => BusinessHoursConfigurationVM }
        ]);
    }
    create(value?: PartialMessage<BusinessHoursRequest>): BusinessHoursRequest {
        const message = { locationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BusinessHoursRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BusinessHoursRequest): BusinessHoursRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* Mgmt.BusinessHoursConfigurationVM configuration */ 2:
                    message.configuration = BusinessHoursConfigurationVM.internalBinaryRead(reader, reader.uint32(), options, message.configuration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BusinessHoursRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* Mgmt.BusinessHoursConfigurationVM configuration = 2; */
        if (message.configuration)
            BusinessHoursConfigurationVM.internalBinaryWrite(message.configuration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.BusinessHoursRequest
 */
export const BusinessHoursRequest = new BusinessHoursRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TipSettingsRequest$Type extends MessageType<TipSettingsRequest> {
    constructor() {
        super("Mgmt.TipSettingsRequest", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "settings", kind: "message", T: () => TipSettingsVM }
        ]);
    }
    create(value?: PartialMessage<TipSettingsRequest>): TipSettingsRequest {
        const message = { locationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TipSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TipSettingsRequest): TipSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* Mgmt.TipSettingsVM settings */ 2:
                    message.settings = TipSettingsVM.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TipSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* Mgmt.TipSettingsVM settings = 2; */
        if (message.settings)
            TipSettingsVM.internalBinaryWrite(message.settings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.TipSettingsRequest
 */
export const TipSettingsRequest = new TipSettingsRequest$Type();
/**
 * @generated ServiceType for protobuf service Mgmt.KioskConfigService
 */
export const KioskConfigService = new ServiceType("Mgmt.KioskConfigService", [
    { name: "GetKioskConfig", options: {}, I: LocationRequest, O: KioskConfigVM },
    { name: "GetOrderTypes", options: {}, I: LocationRequest, O: OrderTypesResponse },
    { name: "UpsertOrderTypes", options: {}, I: UpsertOrderTypesRequest, O: OrderTypesResponse },
    { name: "GetOrderToken", options: {}, I: LocationRequest, O: OrderTokenSettingsVM },
    { name: "UpsertOrderToken", options: {}, I: UpsertOrderTokenRequest, O: OrderTokenSettingsVM },
    { name: "GetLocalization", options: {}, I: LocationRequest, O: LocalizationVM },
    { name: "UpsertLocalization", options: {}, I: LocalizationRequest, O: LocalizationVM },
    { name: "GetAgeVerificationSettings", options: {}, I: LocationRequest, O: AgeVerificationSettingsVM },
    { name: "UpsertAgeVerificationSettings", options: {}, I: AgeVerificationSettingsRequest, O: AgeVerificationSettingsVM },
    { name: "GetTimeoutSettings", options: {}, I: LocationRequest, O: TimeoutSettingsVM },
    { name: "UpsertTimeoutSettings", options: {}, I: TimeoutSettingsRequest, O: TimeoutSettingsVM },
    { name: "GetGratuityTenders", options: {}, I: LocationRequest, O: GratuityTendersVM },
    { name: "GetTipSettings", options: {}, I: LocationRequest, O: TipSettingsVM },
    { name: "UpsertTipSettings", options: {}, I: TipSettingsRequest, O: TipSettingsVM },
    { name: "UpdateConceptFeatureFlag", options: {}, I: ConceptFeatureFlagRequest, O: EmptyResponse },
    { name: "UpdateShowCaloriesFeatureFlag", options: {}, I: FeatureFlagRequest, O: EmptyResponse },
    { name: "UpdateItemSpecialRequestFeatureFlag", options: {}, I: FeatureFlagRequest, O: EmptyResponse },
    { name: "GetConcepts", options: {}, I: LocationRequest, O: ConceptsResponse },
    { name: "CreateConcept", options: {}, I: ConceptRequest, O: ConceptsResponse },
    { name: "UpdateConcept", options: {}, I: ConceptRequest, O: ConceptsResponse },
    { name: "RemoveConcept", options: {}, I: RemoveConceptRequest, O: EmptyResponse },
    { name: "ReorderConcepts", options: {}, I: ReorderConceptsRequest, O: ConceptsResponse },
    { name: "GetBusinessHoursConfiguration", options: {}, I: LocationRequest, O: BusinessHoursConfigurationVM },
    { name: "UpsertBusinessHoursConfiguration", options: {}, I: BusinessHoursRequest, O: BusinessHoursConfigurationVM }
]);
