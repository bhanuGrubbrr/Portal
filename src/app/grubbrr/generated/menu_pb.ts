/* eslint-disable */
// @generated by protobuf-ts 2.9.0 with parameter ts_nocheck,eslint_disable,add_pb_suffix,long_type_string,generate_dependencies
// @generated from protobuf file "menu.proto" (package "Mgmt", syntax proto3)
// tslint:disable
// @ts-nocheck
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message Mgmt.PosVaultResponse
 */
export interface PosVaultResponse {
    /**
     * @generated from protobuf field: Mgmt.Menu menu = 2;
     */
    menu?: Menu;
}
/**
 * @generated from protobuf message Mgmt.MenuLayoutRequest
 */
export interface MenuLayoutRequest {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: string menuLayoutId = 2;
     */
    menuLayoutId: string;
}
/**
 * @generated from protobuf message Mgmt.UpdateMenuLayoutRequest
 */
export interface UpdateMenuLayoutRequest {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: Mgmt.MenuLayout layout = 3;
     */
    layout?: MenuLayout;
}
/**
 * @generated from protobuf message Mgmt.MenuLayout
 */
export interface MenuLayout {
    /**
     * @generated from protobuf field: string menuLayoutId = 1;
     */
    menuLayoutId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated Mgmt.MenuCategoryLayout categories = 3;
     */
    categories: MenuCategoryLayout[];
    /**
     * @generated from protobuf field: repeated Mgmt.MenuItemLayout menuItems = 4;
     */
    menuItems: MenuItemLayout[];
    /**
     * @generated from protobuf field: repeated Mgmt.ModifierGroupLayout modifierGroups = 5;
     */
    modifierGroups: ModifierGroupLayout[];
}
/**
 * @generated from protobuf message Mgmt.MenuLayoutsResponse
 */
export interface MenuLayoutsResponse {
    /**
     * @generated from protobuf field: repeated Mgmt.MenuLayoutResponse layouts = 1;
     */
    layouts: MenuLayoutResponse[];
}
/**
 * @generated from protobuf message Mgmt.MenuLayoutResponse
 */
export interface MenuLayoutResponse {
    /**
     * @generated from protobuf field: Mgmt.MenuLayout layout = 1;
     */
    layout?: MenuLayout;
}
/**
 * @generated from protobuf message Mgmt.MenuCategoryLayout
 */
export interface MenuCategoryLayout {
    /**
     * @generated from protobuf field: string categoryId = 1;
     */
    categoryId: string;
    /**
     * @generated from protobuf field: repeated string menuItemIds = 2;
     */
    menuItemIds: string[];
    /**
     * @generated from protobuf field: repeated Mgmt.MenuCategoryLayout subCategories = 4;
     */
    subCategories: MenuCategoryLayout[];
    /**
     * @generated from protobuf field: int32 numberOfColumns = 5;
     */
    numberOfColumns: number;
    /**
     * @generated from protobuf field: bool loyaltyOnly = 6;
     */
    loyaltyOnly: boolean;
}
/**
 * @generated from protobuf message Mgmt.MenuItemLayout
 */
export interface MenuItemLayout {
    /**
     * @generated from protobuf field: string menuItemId = 1;
     */
    menuItemId: string;
    /**
     * @generated from protobuf field: repeated string modifierGroupIds = 2;
     */
    modifierGroupIds: string[];
}
/**
 * @generated from protobuf message Mgmt.ModifierGroupLayout
 */
export interface ModifierGroupLayout {
    /**
     * @generated from protobuf field: string modifierGroupId = 1;
     */
    modifierGroupId: string;
    /**
     * @generated from protobuf field: repeated string modifierIds = 2;
     */
    modifierIds: string[];
}
/**
 * @generated from protobuf message Mgmt.MenuSection
 */
export interface MenuSection {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string media = 3;
     */
    media: string;
    /**
     * @generated from protobuf field: repeated string menuItemIds = 4;
     */
    menuItemIds: string[];
    /**
     * @generated from protobuf field: bool hasAlcohol = 5;
     */
    hasAlcohol: boolean;
    /**
     * @generated from protobuf field: bool isActive = 6;
     */
    isActive: boolean;
}
/**
 * @generated from protobuf message Mgmt.MenuItem
 */
export interface MenuItem {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: Mgmt.MenuItemDisplayFlow displayFlow = 3;
     */
    displayFlow: MenuItemDisplayFlow;
    /**
     * @generated from protobuf field: repeated string media = 4;
     */
    media: string[];
    /**
     * @generated from protobuf field: string shortDescription = 5;
     */
    shortDescription: string;
    /**
     * @generated from protobuf field: string longDescription = 6;
     */
    longDescription: string;
    /**
     * @generated from protobuf field: int32 price = 7;
     */
    price: number;
    /**
     * @generated from protobuf field: bool isActive = 8;
     */
    isActive: boolean;
    /**
     * @generated from protobuf field: repeated string modifierGroupIds = 9;
     */
    modifierGroupIds: string[];
    /**
     * @generated from protobuf field: repeated string upsellGroupIds = 10;
     */
    upsellGroupIds: string[];
    /**
     * @generated from protobuf field: string calorieText = 11;
     */
    calorieText: string;
    /**
     * @generated from protobuf field: string selectedImage = 12;
     */
    selectedImage: string;
    /**
     * @generated from protobuf field: string selectedDisplayName = 13;
     */
    selectedDisplayName: string;
}
/**
 * @generated from protobuf message Mgmt.ModifierGroup
 */
export interface ModifierGroup {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 selectMin = 3;
     */
    selectMin: number;
    /**
     * @generated from protobuf field: int32 selectMax = 4;
     */
    selectMax: number;
    /**
     * @generated from protobuf field: bool isActive = 5;
     */
    isActive: boolean;
    /**
     * @generated from protobuf field: repeated string modifierIds = 6;
     */
    modifierIds: string[];
    /**
     * @generated from protobuf field: int32 freeModifierCount = 7;
     */
    freeModifierCount: number;
    /**
     * @generated from protobuf field: string displayName = 8;
     */
    displayName: string;
}
/**
 * @generated from protobuf message Mgmt.Modifier
 */
export interface Modifier {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string menuItemId = 2;
     */
    menuItemId: string;
    /**
     * @generated from protobuf field: int32 price = 3;
     */
    price: number;
    /**
     * @generated from protobuf field: bool isDefault = 4;
     */
    isDefault: boolean;
    /**
     * @generated from protobuf field: int32 maxQuantity = 5;
     */
    maxQuantity: number;
    /**
     * @generated from protobuf field: int32 incrementStep = 6;
     */
    incrementStep: number; // NOTE: not sure if needed?
    /**
     * @generated from protobuf field: bool isInvisible = 7;
     */
    isInvisible: boolean;
}
/**
 * @generated from protobuf message Mgmt.MenuResponse
 */
export interface MenuResponse {
    /**
     * @generated from protobuf field: Mgmt.Menu effectiveMenu = 1;
     */
    effectiveMenu?: Menu;
    /**
     * @generated from protobuf field: Mgmt.Menu rawMenu = 2;
     */
    rawMenu?: Menu;
}
/**
 * @generated from protobuf message Mgmt.Menu
 */
export interface Menu {
    /**
     * @generated from protobuf field: repeated Mgmt.MenuSection menuSections = 1;
     */
    menuSections: MenuSection[];
    /**
     * @generated from protobuf field: repeated Mgmt.MenuItem menuItems = 2;
     */
    menuItems: MenuItem[];
    /**
     * @generated from protobuf field: repeated Mgmt.ModifierGroup modifierGroups = 3;
     */
    modifierGroups: ModifierGroup[];
    /**
     * @generated from protobuf field: repeated Mgmt.Modifier modifiers = 4;
     */
    modifiers: Modifier[];
}
/**
 * @generated from protobuf message Mgmt.Item86Response
 */
export interface Item86Response {
    /**
     * @generated from protobuf field: repeated string item86List = 1;
     */
    item86List: string[];
}
/**
 * @generated from protobuf message Mgmt.Item86Request
 */
export interface Item86Request {
    /**
     * @generated from protobuf field: string locationId = 1;
     */
    locationId: string;
    /**
     * @generated from protobuf field: repeated string ids = 2;
     */
    ids: string[];
}
/**
 * @generated from protobuf message Mgmt.MessageVM
 */
export interface MessageVM {
    /**
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * @generated from protobuf field: string subtitle = 2;
     */
    subtitle: string;
}
/**
 * @generated from protobuf message Mgmt.MessageGuardVM
 */
export interface MessageGuardVM {
    /**
     * @generated from protobuf field: Mgmt.MessageVM message = 1;
     */
    message?: MessageVM;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: Mgmt.GuardTrigger trigger = 4;
     */
    trigger: GuardTrigger;
    /**
     * @generated from protobuf field: bool enabled = 5;
     */
    enabled: boolean;
    /**
     * @generated from protobuf field: string image = 6;
     */
    image: string;
    /**
     * @generated from protobuf field: repeated string items = 7;
     */
    items: string[];
    /**
     * @generated from protobuf field: repeated string categories = 8;
     */
    categories: string[];
}
/**
 * @generated from protobuf message Mgmt.IdGuardMapVM
 */
export interface IdGuardMapVM {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string guardId = 2;
     */
    guardId: string;
}
/**
 * @generated from protobuf message Mgmt.MessageGuardMapResponse
 */
export interface MessageGuardMapResponse {
    /**
     * @generated from protobuf field: repeated string items = 1;
     */
    items: string[];
    /**
     * @generated from protobuf field: repeated Mgmt.IdGuardMapVM categories = 2;
     */
    categories: IdGuardMapVM[];
}
/**
 * @generated from protobuf message Mgmt.MessageGuardResponse
 */
export interface MessageGuardResponse {
    /**
     * @generated from protobuf field: repeated Mgmt.MessageGuardVM guards = 1;
     */
    guards: MessageGuardVM[];
}
/**
 * @generated from protobuf enum Mgmt.MenuItemDisplayFlow
 */
export enum MenuItemDisplayFlow {
    /**
     * @generated from protobuf enum value: Default = 0;
     */
    Default = 0,
    /**
     * @generated from protobuf enum value: Builder = 1;
     */
    Builder = 1,
    /**
     * @generated from protobuf enum value: Pizza = 2;
     */
    Pizza = 2
}
/**
 * @generated from protobuf enum Mgmt.GuardTrigger
 */
export enum GuardTrigger {
    /**
     * @generated from protobuf enum value: ADDING_TO_CART = 0;
     */
    ADDING_TO_CART = 0,
    /**
     * @generated from protobuf enum value: AFTER_PAYMENT = 1;
     */
    AFTER_PAYMENT = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class PosVaultResponse$Type extends MessageType<PosVaultResponse> {
    constructor() {
        super("Mgmt.PosVaultResponse", [
            { no: 2, name: "menu", kind: "message", T: () => Menu }
        ]);
    }
    create(value?: PartialMessage<PosVaultResponse>): PosVaultResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PosVaultResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PosVaultResponse): PosVaultResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Mgmt.Menu menu */ 2:
                    message.menu = Menu.internalBinaryRead(reader, reader.uint32(), options, message.menu);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PosVaultResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Mgmt.Menu menu = 2; */
        if (message.menu)
            Menu.internalBinaryWrite(message.menu, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.PosVaultResponse
 */
export const PosVaultResponse = new PosVaultResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MenuLayoutRequest$Type extends MessageType<MenuLayoutRequest> {
    constructor() {
        super("Mgmt.MenuLayoutRequest", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "menuLayoutId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MenuLayoutRequest>): MenuLayoutRequest {
        const message = { locationId: "", menuLayoutId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MenuLayoutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MenuLayoutRequest): MenuLayoutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* string menuLayoutId */ 2:
                    message.menuLayoutId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MenuLayoutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* string menuLayoutId = 2; */
        if (message.menuLayoutId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.menuLayoutId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MenuLayoutRequest
 */
export const MenuLayoutRequest = new MenuLayoutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMenuLayoutRequest$Type extends MessageType<UpdateMenuLayoutRequest> {
    constructor() {
        super("Mgmt.UpdateMenuLayoutRequest", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "layout", kind: "message", T: () => MenuLayout }
        ]);
    }
    create(value?: PartialMessage<UpdateMenuLayoutRequest>): UpdateMenuLayoutRequest {
        const message = { locationId: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMenuLayoutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMenuLayoutRequest): UpdateMenuLayoutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* Mgmt.MenuLayout layout */ 3:
                    message.layout = MenuLayout.internalBinaryRead(reader, reader.uint32(), options, message.layout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMenuLayoutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* Mgmt.MenuLayout layout = 3; */
        if (message.layout)
            MenuLayout.internalBinaryWrite(message.layout, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.UpdateMenuLayoutRequest
 */
export const UpdateMenuLayoutRequest = new UpdateMenuLayoutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MenuLayout$Type extends MessageType<MenuLayout> {
    constructor() {
        super("Mgmt.MenuLayout", [
            { no: 1, name: "menuLayoutId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "categories", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MenuCategoryLayout },
            { no: 4, name: "menuItems", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MenuItemLayout },
            { no: 5, name: "modifierGroups", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ModifierGroupLayout }
        ]);
    }
    create(value?: PartialMessage<MenuLayout>): MenuLayout {
        const message = { menuLayoutId: "", name: "", categories: [], menuItems: [], modifierGroups: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MenuLayout>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MenuLayout): MenuLayout {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string menuLayoutId */ 1:
                    message.menuLayoutId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* repeated Mgmt.MenuCategoryLayout categories */ 3:
                    message.categories.push(MenuCategoryLayout.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Mgmt.MenuItemLayout menuItems */ 4:
                    message.menuItems.push(MenuItemLayout.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Mgmt.ModifierGroupLayout modifierGroups */ 5:
                    message.modifierGroups.push(ModifierGroupLayout.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MenuLayout, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string menuLayoutId = 1; */
        if (message.menuLayoutId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.menuLayoutId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* repeated Mgmt.MenuCategoryLayout categories = 3; */
        for (let i = 0; i < message.categories.length; i++)
            MenuCategoryLayout.internalBinaryWrite(message.categories[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated Mgmt.MenuItemLayout menuItems = 4; */
        for (let i = 0; i < message.menuItems.length; i++)
            MenuItemLayout.internalBinaryWrite(message.menuItems[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated Mgmt.ModifierGroupLayout modifierGroups = 5; */
        for (let i = 0; i < message.modifierGroups.length; i++)
            ModifierGroupLayout.internalBinaryWrite(message.modifierGroups[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MenuLayout
 */
export const MenuLayout = new MenuLayout$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MenuLayoutsResponse$Type extends MessageType<MenuLayoutsResponse> {
    constructor() {
        super("Mgmt.MenuLayoutsResponse", [
            { no: 1, name: "layouts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MenuLayoutResponse }
        ]);
    }
    create(value?: PartialMessage<MenuLayoutsResponse>): MenuLayoutsResponse {
        const message = { layouts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MenuLayoutsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MenuLayoutsResponse): MenuLayoutsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Mgmt.MenuLayoutResponse layouts */ 1:
                    message.layouts.push(MenuLayoutResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MenuLayoutsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Mgmt.MenuLayoutResponse layouts = 1; */
        for (let i = 0; i < message.layouts.length; i++)
            MenuLayoutResponse.internalBinaryWrite(message.layouts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MenuLayoutsResponse
 */
export const MenuLayoutsResponse = new MenuLayoutsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MenuLayoutResponse$Type extends MessageType<MenuLayoutResponse> {
    constructor() {
        super("Mgmt.MenuLayoutResponse", [
            { no: 1, name: "layout", kind: "message", T: () => MenuLayout }
        ]);
    }
    create(value?: PartialMessage<MenuLayoutResponse>): MenuLayoutResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MenuLayoutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MenuLayoutResponse): MenuLayoutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Mgmt.MenuLayout layout */ 1:
                    message.layout = MenuLayout.internalBinaryRead(reader, reader.uint32(), options, message.layout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MenuLayoutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Mgmt.MenuLayout layout = 1; */
        if (message.layout)
            MenuLayout.internalBinaryWrite(message.layout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MenuLayoutResponse
 */
export const MenuLayoutResponse = new MenuLayoutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MenuCategoryLayout$Type extends MessageType<MenuCategoryLayout> {
    constructor() {
        super("Mgmt.MenuCategoryLayout", [
            { no: 1, name: "categoryId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "menuItemIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subCategories", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MenuCategoryLayout },
            { no: 5, name: "numberOfColumns", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "loyaltyOnly", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MenuCategoryLayout>): MenuCategoryLayout {
        const message = { categoryId: "", menuItemIds: [], subCategories: [], numberOfColumns: 0, loyaltyOnly: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MenuCategoryLayout>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MenuCategoryLayout): MenuCategoryLayout {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string categoryId */ 1:
                    message.categoryId = reader.string();
                    break;
                case /* repeated string menuItemIds */ 2:
                    message.menuItemIds.push(reader.string());
                    break;
                case /* repeated Mgmt.MenuCategoryLayout subCategories */ 4:
                    message.subCategories.push(MenuCategoryLayout.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 numberOfColumns */ 5:
                    message.numberOfColumns = reader.int32();
                    break;
                case /* bool loyaltyOnly */ 6:
                    message.loyaltyOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MenuCategoryLayout, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string categoryId = 1; */
        if (message.categoryId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.categoryId);
        /* repeated string menuItemIds = 2; */
        for (let i = 0; i < message.menuItemIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.menuItemIds[i]);
        /* repeated Mgmt.MenuCategoryLayout subCategories = 4; */
        for (let i = 0; i < message.subCategories.length; i++)
            MenuCategoryLayout.internalBinaryWrite(message.subCategories[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 numberOfColumns = 5; */
        if (message.numberOfColumns !== 0)
            writer.tag(5, WireType.Varint).int32(message.numberOfColumns);
        /* bool loyaltyOnly = 6; */
        if (message.loyaltyOnly !== false)
            writer.tag(6, WireType.Varint).bool(message.loyaltyOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MenuCategoryLayout
 */
export const MenuCategoryLayout = new MenuCategoryLayout$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MenuItemLayout$Type extends MessageType<MenuItemLayout> {
    constructor() {
        super("Mgmt.MenuItemLayout", [
            { no: 1, name: "menuItemId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "modifierGroupIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MenuItemLayout>): MenuItemLayout {
        const message = { menuItemId: "", modifierGroupIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MenuItemLayout>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MenuItemLayout): MenuItemLayout {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string menuItemId */ 1:
                    message.menuItemId = reader.string();
                    break;
                case /* repeated string modifierGroupIds */ 2:
                    message.modifierGroupIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MenuItemLayout, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string menuItemId = 1; */
        if (message.menuItemId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.menuItemId);
        /* repeated string modifierGroupIds = 2; */
        for (let i = 0; i < message.modifierGroupIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.modifierGroupIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MenuItemLayout
 */
export const MenuItemLayout = new MenuItemLayout$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModifierGroupLayout$Type extends MessageType<ModifierGroupLayout> {
    constructor() {
        super("Mgmt.ModifierGroupLayout", [
            { no: 1, name: "modifierGroupId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "modifierIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ModifierGroupLayout>): ModifierGroupLayout {
        const message = { modifierGroupId: "", modifierIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModifierGroupLayout>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModifierGroupLayout): ModifierGroupLayout {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string modifierGroupId */ 1:
                    message.modifierGroupId = reader.string();
                    break;
                case /* repeated string modifierIds */ 2:
                    message.modifierIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModifierGroupLayout, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string modifierGroupId = 1; */
        if (message.modifierGroupId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.modifierGroupId);
        /* repeated string modifierIds = 2; */
        for (let i = 0; i < message.modifierIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.modifierIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.ModifierGroupLayout
 */
export const ModifierGroupLayout = new ModifierGroupLayout$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MenuSection$Type extends MessageType<MenuSection> {
    constructor() {
        super("Mgmt.MenuSection", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "media", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "menuItemIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "hasAlcohol", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "isActive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MenuSection>): MenuSection {
        const message = { id: "", name: "", media: "", menuItemIds: [], hasAlcohol: false, isActive: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MenuSection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MenuSection): MenuSection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string media */ 3:
                    message.media = reader.string();
                    break;
                case /* repeated string menuItemIds */ 4:
                    message.menuItemIds.push(reader.string());
                    break;
                case /* bool hasAlcohol */ 5:
                    message.hasAlcohol = reader.bool();
                    break;
                case /* bool isActive */ 6:
                    message.isActive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MenuSection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string media = 3; */
        if (message.media !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.media);
        /* repeated string menuItemIds = 4; */
        for (let i = 0; i < message.menuItemIds.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.menuItemIds[i]);
        /* bool hasAlcohol = 5; */
        if (message.hasAlcohol !== false)
            writer.tag(5, WireType.Varint).bool(message.hasAlcohol);
        /* bool isActive = 6; */
        if (message.isActive !== false)
            writer.tag(6, WireType.Varint).bool(message.isActive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MenuSection
 */
export const MenuSection = new MenuSection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MenuItem$Type extends MessageType<MenuItem> {
    constructor() {
        super("Mgmt.MenuItem", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "displayFlow", kind: "enum", T: () => ["Mgmt.MenuItemDisplayFlow", MenuItemDisplayFlow] },
            { no: 4, name: "media", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "shortDescription", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "longDescription", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "price", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "isActive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "modifierGroupIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "upsellGroupIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "calorieText", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "selectedImage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "selectedDisplayName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MenuItem>): MenuItem {
        const message = { id: "", name: "", displayFlow: 0, media: [], shortDescription: "", longDescription: "", price: 0, isActive: false, modifierGroupIds: [], upsellGroupIds: [], calorieText: "", selectedImage: "", selectedDisplayName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MenuItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MenuItem): MenuItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* Mgmt.MenuItemDisplayFlow displayFlow */ 3:
                    message.displayFlow = reader.int32();
                    break;
                case /* repeated string media */ 4:
                    message.media.push(reader.string());
                    break;
                case /* string shortDescription */ 5:
                    message.shortDescription = reader.string();
                    break;
                case /* string longDescription */ 6:
                    message.longDescription = reader.string();
                    break;
                case /* int32 price */ 7:
                    message.price = reader.int32();
                    break;
                case /* bool isActive */ 8:
                    message.isActive = reader.bool();
                    break;
                case /* repeated string modifierGroupIds */ 9:
                    message.modifierGroupIds.push(reader.string());
                    break;
                case /* repeated string upsellGroupIds */ 10:
                    message.upsellGroupIds.push(reader.string());
                    break;
                case /* string calorieText */ 11:
                    message.calorieText = reader.string();
                    break;
                case /* string selectedImage */ 12:
                    message.selectedImage = reader.string();
                    break;
                case /* string selectedDisplayName */ 13:
                    message.selectedDisplayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MenuItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* Mgmt.MenuItemDisplayFlow displayFlow = 3; */
        if (message.displayFlow !== 0)
            writer.tag(3, WireType.Varint).int32(message.displayFlow);
        /* repeated string media = 4; */
        for (let i = 0; i < message.media.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.media[i]);
        /* string shortDescription = 5; */
        if (message.shortDescription !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.shortDescription);
        /* string longDescription = 6; */
        if (message.longDescription !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.longDescription);
        /* int32 price = 7; */
        if (message.price !== 0)
            writer.tag(7, WireType.Varint).int32(message.price);
        /* bool isActive = 8; */
        if (message.isActive !== false)
            writer.tag(8, WireType.Varint).bool(message.isActive);
        /* repeated string modifierGroupIds = 9; */
        for (let i = 0; i < message.modifierGroupIds.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.modifierGroupIds[i]);
        /* repeated string upsellGroupIds = 10; */
        for (let i = 0; i < message.upsellGroupIds.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.upsellGroupIds[i]);
        /* string calorieText = 11; */
        if (message.calorieText !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.calorieText);
        /* string selectedImage = 12; */
        if (message.selectedImage !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.selectedImage);
        /* string selectedDisplayName = 13; */
        if (message.selectedDisplayName !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.selectedDisplayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MenuItem
 */
export const MenuItem = new MenuItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModifierGroup$Type extends MessageType<ModifierGroup> {
    constructor() {
        super("Mgmt.ModifierGroup", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "selectMin", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "selectMax", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "isActive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "modifierIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "freeModifierCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "displayName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ModifierGroup>): ModifierGroup {
        const message = { id: "", name: "", selectMin: 0, selectMax: 0, isActive: false, modifierIds: [], freeModifierCount: 0, displayName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModifierGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModifierGroup): ModifierGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 selectMin */ 3:
                    message.selectMin = reader.int32();
                    break;
                case /* int32 selectMax */ 4:
                    message.selectMax = reader.int32();
                    break;
                case /* bool isActive */ 5:
                    message.isActive = reader.bool();
                    break;
                case /* repeated string modifierIds */ 6:
                    message.modifierIds.push(reader.string());
                    break;
                case /* int32 freeModifierCount */ 7:
                    message.freeModifierCount = reader.int32();
                    break;
                case /* string displayName */ 8:
                    message.displayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModifierGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 selectMin = 3; */
        if (message.selectMin !== 0)
            writer.tag(3, WireType.Varint).int32(message.selectMin);
        /* int32 selectMax = 4; */
        if (message.selectMax !== 0)
            writer.tag(4, WireType.Varint).int32(message.selectMax);
        /* bool isActive = 5; */
        if (message.isActive !== false)
            writer.tag(5, WireType.Varint).bool(message.isActive);
        /* repeated string modifierIds = 6; */
        for (let i = 0; i < message.modifierIds.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.modifierIds[i]);
        /* int32 freeModifierCount = 7; */
        if (message.freeModifierCount !== 0)
            writer.tag(7, WireType.Varint).int32(message.freeModifierCount);
        /* string displayName = 8; */
        if (message.displayName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.displayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.ModifierGroup
 */
export const ModifierGroup = new ModifierGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Modifier$Type extends MessageType<Modifier> {
    constructor() {
        super("Mgmt.Modifier", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "menuItemId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "price", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "isDefault", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "maxQuantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "incrementStep", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "isInvisible", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Modifier>): Modifier {
        const message = { id: "", menuItemId: "", price: 0, isDefault: false, maxQuantity: 0, incrementStep: 0, isInvisible: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Modifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Modifier): Modifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string menuItemId */ 2:
                    message.menuItemId = reader.string();
                    break;
                case /* int32 price */ 3:
                    message.price = reader.int32();
                    break;
                case /* bool isDefault */ 4:
                    message.isDefault = reader.bool();
                    break;
                case /* int32 maxQuantity */ 5:
                    message.maxQuantity = reader.int32();
                    break;
                case /* int32 incrementStep */ 6:
                    message.incrementStep = reader.int32();
                    break;
                case /* bool isInvisible */ 7:
                    message.isInvisible = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Modifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string menuItemId = 2; */
        if (message.menuItemId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.menuItemId);
        /* int32 price = 3; */
        if (message.price !== 0)
            writer.tag(3, WireType.Varint).int32(message.price);
        /* bool isDefault = 4; */
        if (message.isDefault !== false)
            writer.tag(4, WireType.Varint).bool(message.isDefault);
        /* int32 maxQuantity = 5; */
        if (message.maxQuantity !== 0)
            writer.tag(5, WireType.Varint).int32(message.maxQuantity);
        /* int32 incrementStep = 6; */
        if (message.incrementStep !== 0)
            writer.tag(6, WireType.Varint).int32(message.incrementStep);
        /* bool isInvisible = 7; */
        if (message.isInvisible !== false)
            writer.tag(7, WireType.Varint).bool(message.isInvisible);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.Modifier
 */
export const Modifier = new Modifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MenuResponse$Type extends MessageType<MenuResponse> {
    constructor() {
        super("Mgmt.MenuResponse", [
            { no: 1, name: "effectiveMenu", kind: "message", T: () => Menu },
            { no: 2, name: "rawMenu", kind: "message", T: () => Menu }
        ]);
    }
    create(value?: PartialMessage<MenuResponse>): MenuResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MenuResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MenuResponse): MenuResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Mgmt.Menu effectiveMenu */ 1:
                    message.effectiveMenu = Menu.internalBinaryRead(reader, reader.uint32(), options, message.effectiveMenu);
                    break;
                case /* Mgmt.Menu rawMenu */ 2:
                    message.rawMenu = Menu.internalBinaryRead(reader, reader.uint32(), options, message.rawMenu);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MenuResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Mgmt.Menu effectiveMenu = 1; */
        if (message.effectiveMenu)
            Menu.internalBinaryWrite(message.effectiveMenu, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Mgmt.Menu rawMenu = 2; */
        if (message.rawMenu)
            Menu.internalBinaryWrite(message.rawMenu, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MenuResponse
 */
export const MenuResponse = new MenuResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Menu$Type extends MessageType<Menu> {
    constructor() {
        super("Mgmt.Menu", [
            { no: 1, name: "menuSections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MenuSection },
            { no: 2, name: "menuItems", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MenuItem },
            { no: 3, name: "modifierGroups", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ModifierGroup },
            { no: 4, name: "modifiers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Modifier }
        ]);
    }
    create(value?: PartialMessage<Menu>): Menu {
        const message = { menuSections: [], menuItems: [], modifierGroups: [], modifiers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Menu>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Menu): Menu {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Mgmt.MenuSection menuSections */ 1:
                    message.menuSections.push(MenuSection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Mgmt.MenuItem menuItems */ 2:
                    message.menuItems.push(MenuItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Mgmt.ModifierGroup modifierGroups */ 3:
                    message.modifierGroups.push(ModifierGroup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Mgmt.Modifier modifiers */ 4:
                    message.modifiers.push(Modifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Menu, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Mgmt.MenuSection menuSections = 1; */
        for (let i = 0; i < message.menuSections.length; i++)
            MenuSection.internalBinaryWrite(message.menuSections[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated Mgmt.MenuItem menuItems = 2; */
        for (let i = 0; i < message.menuItems.length; i++)
            MenuItem.internalBinaryWrite(message.menuItems[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated Mgmt.ModifierGroup modifierGroups = 3; */
        for (let i = 0; i < message.modifierGroups.length; i++)
            ModifierGroup.internalBinaryWrite(message.modifierGroups[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated Mgmt.Modifier modifiers = 4; */
        for (let i = 0; i < message.modifiers.length; i++)
            Modifier.internalBinaryWrite(message.modifiers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.Menu
 */
export const Menu = new Menu$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Item86Response$Type extends MessageType<Item86Response> {
    constructor() {
        super("Mgmt.Item86Response", [
            { no: 1, name: "item86List", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Item86Response>): Item86Response {
        const message = { item86List: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Item86Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Item86Response): Item86Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string item86List */ 1:
                    message.item86List.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Item86Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string item86List = 1; */
        for (let i = 0; i < message.item86List.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.item86List[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.Item86Response
 */
export const Item86Response = new Item86Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Item86Request$Type extends MessageType<Item86Request> {
    constructor() {
        super("Mgmt.Item86Request", [
            { no: 1, name: "locationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Item86Request>): Item86Request {
        const message = { locationId: "", ids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Item86Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Item86Request): Item86Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationId */ 1:
                    message.locationId = reader.string();
                    break;
                case /* repeated string ids */ 2:
                    message.ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Item86Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationId = 1; */
        if (message.locationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationId);
        /* repeated string ids = 2; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.Item86Request
 */
export const Item86Request = new Item86Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageVM$Type extends MessageType<MessageVM> {
    constructor() {
        super("Mgmt.MessageVM", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subtitle", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessageVM>): MessageVM {
        const message = { title: "", subtitle: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageVM>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageVM): MessageVM {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string subtitle */ 2:
                    message.subtitle = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageVM, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string subtitle = 2; */
        if (message.subtitle !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subtitle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MessageVM
 */
export const MessageVM = new MessageVM$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageGuardVM$Type extends MessageType<MessageGuardVM> {
    constructor() {
        super("Mgmt.MessageGuardVM", [
            { no: 1, name: "message", kind: "message", T: () => MessageVM },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "trigger", kind: "enum", T: () => ["Mgmt.GuardTrigger", GuardTrigger] },
            { no: 5, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "image", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "items", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "categories", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessageGuardVM>): MessageGuardVM {
        const message = { id: "", name: "", trigger: 0, enabled: false, image: "", items: [], categories: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageGuardVM>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageGuardVM): MessageGuardVM {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Mgmt.MessageVM message */ 1:
                    message.message = MessageVM.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* Mgmt.GuardTrigger trigger */ 4:
                    message.trigger = reader.int32();
                    break;
                case /* bool enabled */ 5:
                    message.enabled = reader.bool();
                    break;
                case /* string image */ 6:
                    message.image = reader.string();
                    break;
                case /* repeated string items */ 7:
                    message.items.push(reader.string());
                    break;
                case /* repeated string categories */ 8:
                    message.categories.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageGuardVM, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Mgmt.MessageVM message = 1; */
        if (message.message)
            MessageVM.internalBinaryWrite(message.message, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* Mgmt.GuardTrigger trigger = 4; */
        if (message.trigger !== 0)
            writer.tag(4, WireType.Varint).int32(message.trigger);
        /* bool enabled = 5; */
        if (message.enabled !== false)
            writer.tag(5, WireType.Varint).bool(message.enabled);
        /* string image = 6; */
        if (message.image !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.image);
        /* repeated string items = 7; */
        for (let i = 0; i < message.items.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.items[i]);
        /* repeated string categories = 8; */
        for (let i = 0; i < message.categories.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.categories[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MessageGuardVM
 */
export const MessageGuardVM = new MessageGuardVM$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdGuardMapVM$Type extends MessageType<IdGuardMapVM> {
    constructor() {
        super("Mgmt.IdGuardMapVM", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "guardId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<IdGuardMapVM>): IdGuardMapVM {
        const message = { id: "", guardId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IdGuardMapVM>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdGuardMapVM): IdGuardMapVM {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string guardId */ 2:
                    message.guardId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdGuardMapVM, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string guardId = 2; */
        if (message.guardId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.guardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.IdGuardMapVM
 */
export const IdGuardMapVM = new IdGuardMapVM$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageGuardMapResponse$Type extends MessageType<MessageGuardMapResponse> {
    constructor() {
        super("Mgmt.MessageGuardMapResponse", [
            { no: 1, name: "items", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "categories", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => IdGuardMapVM }
        ]);
    }
    create(value?: PartialMessage<MessageGuardMapResponse>): MessageGuardMapResponse {
        const message = { items: [], categories: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageGuardMapResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageGuardMapResponse): MessageGuardMapResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string items */ 1:
                    message.items.push(reader.string());
                    break;
                case /* repeated Mgmt.IdGuardMapVM categories */ 2:
                    message.categories.push(IdGuardMapVM.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageGuardMapResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string items = 1; */
        for (let i = 0; i < message.items.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.items[i]);
        /* repeated Mgmt.IdGuardMapVM categories = 2; */
        for (let i = 0; i < message.categories.length; i++)
            IdGuardMapVM.internalBinaryWrite(message.categories[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MessageGuardMapResponse
 */
export const MessageGuardMapResponse = new MessageGuardMapResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageGuardResponse$Type extends MessageType<MessageGuardResponse> {
    constructor() {
        super("Mgmt.MessageGuardResponse", [
            { no: 1, name: "guards", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MessageGuardVM }
        ]);
    }
    create(value?: PartialMessage<MessageGuardResponse>): MessageGuardResponse {
        const message = { guards: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageGuardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageGuardResponse): MessageGuardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Mgmt.MessageGuardVM guards */ 1:
                    message.guards.push(MessageGuardVM.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageGuardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Mgmt.MessageGuardVM guards = 1; */
        for (let i = 0; i < message.guards.length; i++)
            MessageGuardVM.internalBinaryWrite(message.guards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Mgmt.MessageGuardResponse
 */
export const MessageGuardResponse = new MessageGuardResponse$Type();
